package com.liu.FunTestsOfProgrammer.exercise;

/**
 * Created by liu on 218/02/28.
 */
public class FT022_UncrossLine {
    /**
     * 用绳子连接纸杯制作“纸杯电话”——这应该勾起了很多人对理科
     * 实验的回忆。如果把绳子拉直,对着一边的纸杯讲话,声音就可以从另
     * 一边的纸杯传出。
     * 假设有几个小朋友以相同间隔围成圆周,要结对用纸杯电话相互通
     * 话。如果绳子交叉,很有可能会缠绕起来,所以结对的原则是不能让绳
     * 子交叉。
     * 举个例子,如果有 6 个小朋友,则只要如下图一样结对,就可以顺
     * 利用纸杯电话通话。也就是说,6 个人的时候,有 5 种结对方式。
     * .  1-2     1 2     1 2   1-2     1 2
     * .         /  \    / /            \ \
     * . 3---4  3    4  3 / 4  3   4  3 \ 4
     * .                 / /   \  /   \ \
     * .  5-6    5-6    5 6    5 6    5  6
     * <p>
     * 问题：
     * 求有 16 个小朋友的时候,一共有多少种结对方式?
     * <p>
     * Hint:
     * 为简化对交叉的判断,请先划分出范围再进行思考。
     */

    // 首先我们认为有个切分过程，逐步切分，直到最后每个组只有2个成员
    // 且为了保证不出现交叉，则每次切分切出的部分必须均为偶数
    // 每次划分会出现两个区域，在划分的两个区域种，中各自计算结对方式，再把两个区域内的结对方式数相乘就可以了
    // 这样后者的结果依赖于前者的计算结果的方式，可以使用动态规划来处理
    // 2个人的时候有1种结对方式，所以初始值为1
    public static int getUncrossLineMy1(int number) {
        int[] cache = new int[number / 2 + 1];
        cache[0] = 1;
        for (int i = 1; i < number / 2 + 1; i++) {
            cache[i] = 0;
            for (int j = 0; j < i; j++) {
                cache[i] += cache[j] * cache[i - j - 1];
            }
        }
        return cache[number / 2];
    }
}